<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3:nodes - Production Monitoring</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Tone.js for sound synthesis -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.17.1/firebase-app.js";
        import { getFirestore, collection, onSnapshot, doc, setDoc, deleteDoc, writeBatch, query, orderBy, addDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.17.1/firebase-firestore.js";
        
        // --- IMPORTANT: REPLACE WITH YOUR FIREBASE CONFIG ---
        const firebaseConfig = {
  apiKey: "AIzaSyAlgesvhQe-yPxOdrdTasOFWhh88RxHsmI",
  authDomain: "rockers-a2c48.firebaseapp.com",
  projectId: "rockers-a2c48",
  storageBucket: "rockers-a2c48.firebasestorage.app",
  messagingSenderId: "518428210643",
  appId: "1:518428210643:web:ca3db6dd1a22844c452b26",
  measurementId: "G-1S1D9J4TGW"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // Make db and Firestore functions globally available to the main script
        window.db = db;
        window.firestore = { collection, onSnapshot, doc, setDoc, deleteDoc, writeBatch, query, orderBy, addDoc, serverTimestamp };
    </script>
    <style>
        :root {
            --bg-color: #242A31;
            --container-bg-color: #2d3748;
            --node-bg: #374151;
            --node-header: #4a5568;
            --text-color: #e2e8f0;
            --text-muted: #a0aec0;
            --border-color: #4b5563;
            --accent-green: #00D084;
            --color-design: #1abc9c; --color-large-format: #8e44ad; --color-vinyl: #2980b9;
            --color-cutting: #c0392b; --color-cnc: #d35400; --color-finishing: #f39c12;
            --color-delivery: #27ae60; --color-dispatch: #7f8c8d;
            --color-pm: #FFBF00; --color-bo: #3498DB; --color-jor: #2ECC71;
            --color-sor: #E67E22; --color-cd: #95A5A6;
            --status-pending-bg: #4b5563; --status-pending-text: #e2e8f0; --status-progress-bg: #f59e0b;
            --status-progress-text: #1f2937; --status-completed-bg: #16a34a; --status-completed-text: #ffffff;
            --status-blocked-bg: #dc2626; --status-blocked-text: #ffffff;
        }
        html, body {
            overscroll-behavior: none;
        }
        body { font-family: 'Inter', sans-serif; background-color: var(--bg-color); color: var(--text-color); overflow: hidden; }
        .btn { padding: 10px 20px; border-radius: 8px; font-weight: 600; transition: all 0.2s; cursor: pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.1); text-align: center; border: none; }
        .btn-primary { background-color: var(--accent-green); color: white; }
        .btn-primary:hover { opacity: 0.9; transform: translateY(-1px); }
        .btn-secondary { background-color: #4a5568; color: white; }
        .btn-secondary:hover { background-color: #6b7280; transform: translateY(-1px); }
        .btn-danger { background-color: #b91c1c; color: white; }
        .btn-danger:hover { background-color: #991b1b; }
        .modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); z-index: 999; display: none; }
        .modal-box { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: var(--container-bg-color); padding: 1.5rem 2rem; border-radius: 12px; box-shadow: 0 10px 25px rgba(0,0,0,0.4); z-index: 1000; width: 90%; max-width: 500px; color: var(--text-color); display: none; }
        .form-group { margin-bottom: 1.5rem; }
        .form-group label { display: block; margin-bottom: 0.5rem; font-weight: 500; color: var(--text-muted); }
        .form-group input, .form-group select, .form-group textarea { width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; background-color: var(--node-bg); color: var(--text-color); }
        .form-group textarea { min-height: 80px; resize: vertical; }
        .prefix-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 0.75rem; }
        .prefix-btn { padding: 0.75rem; border: 2px solid transparent; border-radius: 6px; font-weight: 700; cursor: pointer; transition: all 0.2s; }
        .prefix-btn.selected { border-color: var(--accent-green); box-shadow: 0 0 10px rgba(0, 208, 132, 0.5); }
        input[type="range"] { -webkit-appearance: none; appearance: none; width: 100%; height: 8px; background: #4b5563; outline: none; border-radius: 4px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: var(--accent-green); cursor: pointer; border-radius: 50%; }
        #jobs-list-view { padding: 2rem 1.5rem; height: 100vh; overflow-y: auto; }
        .job-card { background-color: var(--container-bg-color); border-radius: 0.75rem; padding: 1rem 1.5rem; margin-bottom: 1rem; box-shadow: 0 4px 6px rgba(0,0,0,0.2); transition: transform 0.2s, box-shadow 0.2s, opacity 0.3s; border-left: 5px solid transparent; position: relative; }
        .job-card.completed { opacity: 0.6; }
        .job-card-content { cursor: pointer; }
        .job-card-title { display: flex; align-items: center; gap: 0.75rem; font-size: 1.25rem; font-weight: 700; }
        .job-prefix-badge { padding: 3px 8px; border-radius: 6px; color: black; font-size: 1rem; font-weight: bold; }
        .node-type-badge { padding: 2px 6px; border-radius: 4px; color: white; font-weight: bold; font-size: 0.8em; display: inline-block; }
        .job-description { color: var(--text-muted); font-size: 0.9rem; margin-top: 0.5rem; }
        .delete-job-btn { position: absolute; top: 0.75rem; right: 0.75rem; background: none; border: none; color: var(--text-muted); font-size: 1.2rem; cursor: pointer; padding: 5px; border-radius: 50%; transition: background-color 0.2s, color 0.2s; }
        .delete-job-btn:hover { background-color: var(--status-blocked-bg); color: white; }
        .progress-bar-container { background-color: var(--node-bg); border-radius: 9999px; height: 1.25rem; overflow: hidden; display: flex; margin-top: 1rem; position: relative; }
        .progress-bar-segment { height: 100%; transition: width 0.5s ease-in-out; }
        .progress-bar-text { font-size: 0.8rem; font-weight: 600; text-align: center; line-height: 1.25rem; color: white; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); position: absolute; width: 100%; left: 0; }
        #node-editor-view { display: none; width: 100vw; height: 100vh; overflow: hidden; }
        #nodes-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-image: linear-gradient(rgba(255, 255, 255, 0.07) 1px, transparent 1px), linear-gradient(90deg, rgba(255, 255, 255, 0.07) 1px, transparent 1px); background-size: 30px 30px; cursor: grab; }
        #nodes-world { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform-origin: 0 0; }
        #svg-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .node { position: absolute; background-color: var(--node-bg); border: 1px solid var(--border-color); border-radius: 0.5rem; box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1); width: 180px; user-select: none; display: flex; flex-direction: column; pointer-events: all; }
        .node-header { padding: 0.4rem 0.6rem; font-size: 0.9rem; border-bottom: 1px solid var(--border-color); cursor: move; font-weight: 600; display: flex; justify-content: space-between; align-items: center; }
        .node-content { padding: 0.6rem; display: flex; flex-direction: column; gap: 0.5rem; flex-grow: 1; }
        .node-connector { width: 24px; height: 24px; background-color: #6b728080; border: 2px solid var(--node-bg); border-radius: 9999px; position: absolute; z-index: 2; cursor: crosshair; }
        .node-connector:hover { background-color: var(--accent-green); transform: scale(1.2); }
        .node-connector.left { left: -13px; top: 50%; margin-top: -12px; } .node-connector.right { right: -13px; top: 50%; margin-top: -12px; }
        .node-connector.top { top: -13px; left: 50%; margin-left: -12px; } .node-connector.bottom { bottom: -13px; left: 50%; margin-left: -12px; }
        .comment-textarea { width: 100%; background-color: #2d3748; border: 1px solid var(--border-color); border-radius: 0.375rem; padding: 0.4rem; font-size: 0.8rem; min-height: 40px; resize: vertical; }
        #context-menu, .popover { position: absolute; background-color: var(--node-bg); border: 1px solid var(--border-color); border-radius: 0.5rem; padding: 0.5rem; z-index: 1000; box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1); }
        .context-menu-item, .popover-item { padding: 0.5rem 1rem; border-radius: 0.25rem; cursor: pointer; font-weight: 500; }
        .context-menu-item:hover, .popover-item:hover { background-color: var(--node-header); }
        .top-ui-bar { position: absolute; top: 1rem; left: 1rem; z-index: 10; display: flex; gap: 0.75rem; align-items: center; }
        .line-path { transition: stroke 0.2s; }
        .line-path.selected { stroke: var(--accent-green) !important; stroke-width: 4px !important; }
        .popover-container { position: relative; }
        .popover-trigger-btn { width: 100%; border: 1px solid var(--border-color); border-radius: 0.375rem; padding: 0.4rem; font-size: 0.85rem; font-weight: 500; cursor: pointer; text-align: left; }
        .assigned-items-display { display: flex; flex-wrap: wrap; gap: 4px; margin-top: 4px; min-height: 18px; }
        .item-badge { background-color: var(--accent-green); color: black; padding: 2px 6px; font-size: 0.75rem; font-weight: 700; border-radius: 4px; }
        .item-selector-popover { display: none; max-height: 150px; overflow-y: auto; }
        .item-selector-popover label { display: block; padding: 0.25rem 0.5rem; border-radius: 4px; cursor: pointer; }
        .item-selector-popover label:hover { background-color: var(--node-header); }
        .comment-box { margin-top: 0.5rem; display: flex; flex-direction: column; gap: 0.5rem; }
        .feed-container { background-color: var(--container-bg-color); border-radius: 0.75rem; margin-top: 2rem; }
        .feed-header { padding: 1rem 1.5rem; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-size: 1.25rem; font-weight: 700; }
        .feed-content { max-height: 300px; overflow-y: auto; padding: 0 1.5rem 1rem; display: none; }
        .feed-item { padding: 0.75rem 0; border-bottom: 1px solid var(--border-color); }
        .feed-item:last-child { border-bottom: none; }
        .feed-meta { font-size: 0.9rem; display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.25rem; }
        .feed-timestamp { font-size: 0.75rem; color: var(--text-muted); margin-left: auto; }
        .feed-message { padding-left: 0.5rem; }
    </style>
</head>
<body class="bg-gray-800">

    <div id="jobs-list-view">
        <div class="max-w-4xl mx-auto">
            <header class="flex justify-between items-center mb-8">
                 <div class="flex items-center gap-4">
                    <a href="index.html" class="btn btn-secondary">&larr; Home</a>
                    <h1 class="text-4xl font-bold">Production Jobs</h1>
                </div>
                <button id="add-job-btn" class="btn btn-primary">+ Add Job</button>
            </header>
            <main id="jobs-container"></main>
            <section id="production-feed-container" class="feed-container">
                <div id="production-feed-header" class="feed-header">
                    <h2>Production Feed</h2>
                    <span id="feed-arrow">▼</span>
                </div>
                <div id="production-feed-content" class="feed-content"></div>
            </section>
        </div>
    </div>

    <div id="node-editor-view">
        <div class="top-ui-bar">
            <button id="back-to-jobs-btn" class="btn btn-secondary">&larr; Back to Jobs</button>
        </div>
        <div id="nodes-canvas"><div id="nodes-world"></div><svg id="svg-container"></svg></div>
    </div>

    <div id="add-job-modal-backdrop" class="modal-backdrop"></div>
    <div id="add-job-modal" class="modal-box">
        <div id="modal-step-1">
            <h3 class="text-2xl font-bold mb-2">New Job</h3>
            <p class="text-gray-400 mb-6">Select a prefix, enter the job number, and add a description.</p>
            <div class="form-group"><label>Prefix</label><div id="job-prefix-container" class="prefix-grid"></div></div>
            <div class="form-group"><label for="job-number">Job Number (5 digits)</label><input type="text" id="job-number" placeholder="12345" maxlength="5"></div>
            <div class="form-group"><label for="job-description">Description</label><textarea id="job-description" placeholder="e.g., Banners for summer festival"></textarea></div>
            <div class="flex justify-end gap-4 mt-8"><button id="modal-cancel-1" class="btn btn-secondary">Cancel</button><button id="modal-next-1" class="btn btn-primary">Next &rarr;</button></div>
        </div>
        <div id="modal-step-2" style="display: none;">
            <h3 class="text-2xl font-bold mb-2">Number of Items</h3>
            <p class="text-gray-400 mb-6">Specify how many parts this job consists of.</p>
            <div class="form-group">
                <div class="flex justify-between items-center mb-2"><label for="item-count-slider">Number of Items</label><span id="item-count-value" class="text-2xl font-bold">15</span></div>
                <input type="range" id="item-count-slider" min="1" max="50" value="15">
            </div>
            <div class="flex justify-between gap-4 mt-8"><button id="modal-back-2" class="btn btn-secondary">&larr; Back</button><button id="modal-create-job" class="btn btn-primary">Create Job</button></div>
        </div>
    </div>

    <script type="module">
        const { db, firestore } = window;
        const { collection, onSnapshot, doc, setDoc, deleteDoc, writeBatch, query, orderBy, addDoc, serverTimestamp } = firestore;

        const salespeople = [ { name: "Patrice (PM)", prefix: "PM", color: "var(--color-pm)" }, { name: "Brendan (BO)", prefix: "BO", color: "var(--color-bo)" }, { name: "John (JOR)", prefix: "JOR", color: "var(--color-jor)" }, { name: "Sean (SOR)", prefix: "SOR", color: "var(--color-sor)" }, { name: "House Account (CD)", prefix: "CD", color: "var(--color-cd)" }];
        const nodeTypes = { 'Design': { color: 'var(--color-design)', note: 'C5' }, 'Large Format': { color: 'var(--color-large-format)', note: 'D5' }, 'Vinyl': { color: 'var(--color-vinyl)', note: 'E5' }, 'Cutting': { color: 'var(--color-cutting)', note: 'F5' }, 'CNC': { color: 'var(--color-cnc)', note: 'G5' }, 'Finishing': { color: 'var(--color-finishing)', note: 'A5' }, 'Delivery': { color: 'var(--color-delivery)', note: 'B5' }, 'Dispatch': { color: 'var(--color-dispatch)', note: 'C6' }};
        const statuses = { pending: { text: 'Pending', bg: 'var(--status-pending-bg)'}, progress: { text: 'In Progress', bg: 'var(--status-progress-bg)'}, completed: { text: 'Completed', bg: 'var(--status-completed-bg)'}, blocked: { text: 'Blocked', bg: 'var(--status-blocked-bg)'}};

        let jobs = [];
        let nodeMaps = {};
        let currentJobId = null;
        let selectedLineId = null;
        let feedComments = [];

        const jobsListView = document.getElementById('jobs-list-view'), nodeEditorView = document.getElementById('node-editor-view'), jobsContainer = document.getElementById('jobs-container'), addJobBtn = document.getElementById('add-job-btn'), backToJobsBtn = document.getElementById('back-to-jobs-btn'), modalBackdrop = document.getElementById('add-job-modal-backdrop'), modal = document.getElementById('add-job-modal'), modalStep1 = document.getElementById('modal-step-1'), modalStep2 = document.getElementById('modal-step-2'), prefixContainer = document.getElementById('job-prefix-container');
        let selectedPrefix = null, canvas, world, svgContainer, resizeObserver;
        let nodes = {}, lines = [], pan = { x: 0, y: 0 }, zoom = 1, isPanning = false, panStart = { x: 0, y: 0 }, activeDrag = null, isConnecting = null;

        let initialTouchDistance = null;
        let longPressTimeout = null;
        let synth; // To hold the Tone.js synthesizer

        const jobsCollection = collection(db, "jobs");
        const nodeMapsCollection = collection(db, "nodeMaps");
        const feedCollection = collection(db, "productionFeed");

        function playSoundForNodeType(nodeType) {
            if (typeof Tone === 'undefined' || !Tone.context.state === 'running') return;
            const note = nodeTypes[nodeType]?.note;
            if (note) {
                if (!synth) {
                    synth = new Tone.Synth().toDestination();
                }
                synth.triggerAttackRelease(note, "8n");
            }
        }

        function listenForData() {
            onSnapshot(query(jobsCollection, orderBy("prefix"), orderBy("number")), (snapshot) => {
                jobs = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderJobsList();
            });
            onSnapshot(nodeMapsCollection, (snapshot) => {
                nodeMaps = {};
                snapshot.docs.forEach(doc => { nodeMaps[doc.id] = doc.data(); });
                renderJobsList();
            });
            onSnapshot(query(feedCollection, orderBy("timestamp", "desc")), (snapshot) => {
                snapshot.docChanges().forEach(change => {
                    if (change.type === "added" && !change.doc.metadata.hasPendingWrites) {
                        const newComment = change.doc.data();
                        playSoundForNodeType(newComment.nodeType);
                    }
                });
                feedComments = snapshot.docs.map(doc => doc.data());
                renderProductionFeed();
            });
        }
        
        async function deleteJob(jobId) {
            if (!jobId) return;
            if (confirm(`Are you sure you want to delete this job? This action cannot be undone.`)) {
                try {
                    const batch = writeBatch(db);
                    batch.delete(doc(jobsCollection, jobId));
                    batch.delete(doc(nodeMapsCollection, jobId));
                    await batch.commit();
                } catch (error) { console.error("Error deleting job: ", error); alert("Failed to delete job."); }
            }
        }
        
        function showJobsList() { jobsListView.style.display = 'block'; nodeEditorView.style.display = 'none'; currentJobId = null; }
        function showNodeEditor(jobId) { currentJobId = jobId; jobsListView.style.display = 'none'; nodeEditorView.style.display = 'block'; initializeNodeEditor(); loadNodeState(jobId); }

        function renderJobsList() {
            jobsContainer.innerHTML = '';
            if (jobs.length === 0) { jobsContainer.innerHTML = `<p class="text-center text-gray-400 py-10">No jobs found. Click "+ Add Job" to start.</p>`; return; }
            const incompleteJobs = [], completedJobs = [];
            jobs.forEach(job => {
                const { percentage } = calculateProgress(job.id);
                if (percentage === 100) completedJobs.push({ ...job, percentage });
                else incompleteJobs.push({ ...job, percentage });
            });
            const sortedIncomplete = incompleteJobs.sort((a,b) => (a.prefix+a.number).localeCompare(b.prefix+b.number));
            const sortedCompleted = completedJobs.sort((a,b) => (a.prefix+a.number).localeCompare(b.prefix+b.number));
            const allSortedJobs = [...sortedIncomplete, ...sortedCompleted];
            allSortedJobs.forEach(job => {
                const jobCard = document.createElement('div');
                jobCard.className = 'job-card';
                if (job.percentage === 100) jobCard.classList.add('completed');
                jobCard.style.borderLeftColor = job.color;
                const { percentage, segments } = calculateProgress(job.id);
                jobCard.innerHTML = `
                    <div class="job-card-content">
                        <div class="job-card-title">
                            <span class="job-prefix-badge" style="background-color: ${job.color};">${job.prefix}</span>
                            <span>${job.number}</span>
                        </div>
                        <p class="job-description">${job.description || 'No description.'}</p>
                        <div class="progress-bar-container">
                            ${segments.map(seg => `<div class="progress-bar-segment" style="width: ${seg.width}%; background-color: ${seg.color};"></div>`).join('')}
                             <div class="progress-bar-text">${percentage.toFixed(0)}%</div>
                        </div>
                    </div>
                    <button class="delete-job-btn" title="Delete Job">&times;</button>
                `;
                jobCard.querySelector('.job-card-content').addEventListener('click', () => showNodeEditor(job.id));
                jobCard.querySelector('.delete-job-btn').addEventListener('click', (e) => { e.stopPropagation(); deleteJob(job.id); });
                jobsContainer.appendChild(jobCard);
            });
        }
        
        function renderProductionFeed() {
            const contentEl = document.getElementById('production-feed-content');
            if(!contentEl) return;
            contentEl.innerHTML = feedComments.length > 0 ? '' : '<p class="text-center text-gray-500 py-4">No comments yet.</p>';
            feedComments.forEach(comment => {
                const itemEl = document.createElement('div');
                itemEl.className = 'feed-item';
                const job = jobs.find(j => j.id === comment.jobId);
                const prefixColor = job ? job.color : 'var(--text-muted)';
                const nodeTypeColor = nodeTypes[comment.nodeType]?.color || 'var(--text-muted)';

                itemEl.innerHTML = `
                    <div class="feed-meta">
                        <span class="job-prefix-badge" style="background-color: ${prefixColor};">${comment.jobPrefix}</span>
                        <strong>${comment.jobNumber}</strong>
                        <span>&rarr;</span>
                        <span class="node-type-badge" style="background-color: ${nodeTypeColor};">${comment.nodeType}</span>
                        <span class="feed-timestamp">${comment.timestamp?.toDate().toLocaleString('en-GB') || ''}</span>
                    </div>
                    <p class="feed-message">${comment.message}</p>
                `;
                contentEl.appendChild(itemEl);
            });
        }

        function calculateProgress(jobId) {
            const job = jobs.find(j => j.id === jobId); const map = nodeMaps[jobId];
            if (!job || !map || !map.nodes || Object.keys(map.nodes).length === 0) return { percentage: 0, segments: [] };
            const nodeValues = Object.values(map.nodes);
            if (job.itemCount === 0) {
                const completedNodes = nodeValues.filter(n => n.status === 'completed'); const totalNodes = nodeValues.length;
                const percentage = totalNodes > 0 ? (completedNodes.length / totalNodes) * 100 : 0;
                const segments = completedNodes.map(node => ({ width: 100 / totalNodes, color: nodeTypes[node.type]?.color || 'var(--text-muted)' }));
                return { percentage, segments };
            }
            let totalWorkUnits = 0; const completedWorkUnitsByNodeType = {};
            for (let i = 1; i <= job.itemCount; i++) {
                const currentItem = String(i);
                const nodesWithItem = nodeValues.filter(node => Array.isArray(node.items) && node.items.includes(currentItem));
                totalWorkUnits += nodesWithItem.length;
                nodesWithItem.forEach(node => {
                    if (node.status === 'completed') {
                        if (!completedWorkUnitsByNodeType[node.type]) completedWorkUnitsByNodeType[node.type] = 0;
                        completedWorkUnitsByNodeType[node.type]++;
                    }
                });
            }
            if (totalWorkUnits === 0) return { percentage: 0, segments: [] };
            const totalCompletedWorkUnits = Object.values(completedWorkUnitsByNodeType).reduce((sum, count) => sum + count, 0);
            const percentage = totalWorkUnits > 0 ? (totalCompletedWorkUnits / totalWorkUnits) * 100 : 0;
            const segments = Object.entries(completedWorkUnitsByNodeType).map(([nodeType, count]) => ({ width: (count / totalWorkUnits) * 100, color: nodeTypes[nodeType]?.color || 'var(--text-muted)' }));
            return { percentage, segments };
        }

        function openAddJobModal() {
            prefixContainer.innerHTML = salespeople.map(sp => `<button class="prefix-btn" data-prefix="${sp.prefix}" style="background-color: ${sp.color}; color: black;">${sp.prefix}</button>`).join('');
            prefixContainer.querySelectorAll('.prefix-btn').forEach(btn => btn.addEventListener('click', e => { prefixContainer.querySelectorAll('.prefix-btn').forEach(b => b.classList.remove('selected')); e.currentTarget.classList.add('selected'); selectedPrefix = salespeople.find(sp => sp.prefix === e.currentTarget.dataset.prefix); }));
            document.getElementById('job-number').value = ''; document.getElementById('job-description').value = '';
            document.getElementById('item-count-slider').value = 15; document.getElementById('item-count-value').textContent = 15;
            selectedPrefix = null;
            modal.style.display = 'block'; modalBackdrop.style.display = 'block'; modalStep1.style.display = 'block'; modalStep2.style.display = 'none';
        }

        function closeAddJobModal() { modal.style.display = 'none'; modalBackdrop.style.display = 'none'; }

        async function handleCreateJob() {
            const number = document.getElementById('job-number').value; const description = document.getElementById('job-description').value; const itemCount = document.getElementById('item-count-slider').value;
            if (!selectedPrefix) { alert("Please select a prefix."); return; }
            if (!/^\d{5}$/.test(number)) { alert("Job number must be 5 digits."); return; }
            const jobId = `job_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
            const newJob = { id: jobId, prefix: selectedPrefix.prefix, number, description, itemCount: parseInt(itemCount, 10), color: selectedPrefix.color };
            const newNodeMap = { nodes: {}, lines: [] };
            try {
                const batch = writeBatch(db);
                batch.set(doc(jobsCollection, jobId), newJob);
                batch.set(doc(nodeMapsCollection, jobId), newNodeMap);
                await batch.commit();
                closeAddJobModal();
            } catch (error) { console.error("Error creating job:", error); alert("Failed to create job."); }
        }
        
        function getTouchCoords(e) { return { x: e.touches[0].clientX, y: e.touches[0].clientY }; }
        function getDistance(t1, t2) { return Math.sqrt(Math.pow(t1.clientX - t2.clientX, 2) + Math.pow(t1.clientY - t2.clientY, 2)); }
        
        function initializeNodeEditor() {
            if (canvas) return;
            canvas = document.getElementById('nodes-canvas'); world = document.getElementById('nodes-world'); svgContainer = document.getElementById('svg-container');
            resizeObserver = new ResizeObserver(entries => { for (const entry of entries) if (nodes[entry.target.id]) updateLinesForNode(entry.target.id); });
            canvas.addEventListener('wheel', e => { e.preventDefault(); const rect = canvas.getBoundingClientRect(); const mx = e.clientX - rect.left, my = e.clientY - rect.top; const wx = (mx - pan.x) / zoom, wy = (my - pan.y) / zoom; let nz = e.deltaY < 0 ? zoom * 1.1 : zoom / 1.1; nz = Math.max(0.2, Math.min(nz, 3)); pan.x = mx - wx * nz; pan.y = my - wy * nz; zoom = nz; updateView(); });
            canvas.addEventListener('mousedown', e => { if (e.target.closest('.node') || e.target.closest('.popover')) return; if (e.button === 0) { isPanning = true; panStart = { x: e.clientX, y: e.clientY }; canvas.style.cursor = 'grabbing'; } closeAllPopovers(); deselectLine(); });
            canvas.addEventListener('contextmenu', e => { e.preventDefault(); closeAllPopovers(); showContextMenu(e.clientX, e.clientY); });
            canvas.addEventListener('touchstart', e => { e.preventDefault(); closeAllPopovers(); deselectLine(); const targetIsNode = e.target.closest('.node'); if (e.touches.length === 2) { initialTouchDistance = getDistance(e.touches[0], e.touches[1]); } else if (e.touches.length === 1 && !targetIsNode) { isPanning = true; panStart = getTouchCoords(e); longPressTimeout = setTimeout(() => { isPanning = false; showContextMenu(e.touches[0].clientX, e.touches[0].clientY); }, 500); } }, { passive: false });
            canvas.addEventListener('touchmove', e => { e.preventDefault(); if (longPressTimeout) clearTimeout(longPressTimeout); if (e.touches.length === 2 && initialTouchDistance) { isPanning = false; const newDist = getDistance(e.touches[0], e.touches[1]); const rect = canvas.getBoundingClientRect(); const t1 = {clientX: e.touches[0].clientX, clientY: e.touches[0].clientY}; const t2 = {clientX: e.touches[1].clientX, clientY: e.touches[1].clientY}; const mx = (t1.clientX + t2.clientX) / 2 - rect.left; const my = (t1.clientY + t2.clientY) / 2 - rect.top; const wx = (mx - pan.x) / zoom; const wy = (my - pan.y) / zoom; let newZoom = zoom * (newDist / initialTouchDistance); newZoom = Math.max(0.2, Math.min(newZoom, 3)); pan.x = mx - wx * newZoom; pan.y = my - wy * newZoom; zoom = newZoom; initialTouchDistance = newDist; updateView(); } else if (isPanning && e.touches.length === 1) { const touch = getTouchCoords(e); const dx = touch.x - panStart.x; const dy = touch.y - panStart.y; pan.x += dx; pan.y += dy; panStart = touch; updateView(); } }, { passive: false });
            canvas.addEventListener('touchend', e => { clearTimeout(longPressTimeout); if (e.touches.length < 2) initialTouchDistance = null; if (e.touches.length < 1) isPanning = false; });
            window.addEventListener('mousemove', handlePointerMove); window.addEventListener('touchmove', handlePointerMove, { passive: false });
            window.addEventListener('mouseup', handlePointerUp); window.addEventListener('touchend', handlePointerUp);
            window.addEventListener('keydown', e => { if (e.key === 'Delete' || e.key === 'Backspace') deleteSelectedLine(); });
        }
        
        function handlePointerMove(e) {
            let pointer = e;
            if (e.touches && e.touches.length > 0) { if(e.touches.length > 1) return; pointer = e.touches[0]; }
            else if (e.touches && e.touches.length === 0) return;
            if (isPanning && !activeDrag && !isConnecting) { const dx = pointer.clientX - panStart.x; const dy = pointer.clientY - panStart.y; pan.x += dx; pan.y += dy; panStart = { x: pointer.clientX, y: pointer.clientY }; updateView(); }
            else if (activeDrag) { e.preventDefault(); const dx = pointer.clientX - activeDrag.lastMouse.x; const dy = pointer.clientY - activeDrag.lastMouse.y; nodes[activeDrag.nodeId].x += dx / zoom; nodes[activeDrag.nodeId].y += dy / zoom; activeDrag.el.style.left = `${nodes[activeDrag.nodeId].x}px`; activeDrag.el.style.top = `${nodes[activeDrag.nodeId].y}px`; activeDrag.lastMouse = { x: pointer.clientX, y: pointer.clientY }; updateAllLines(); } 
            else if (isConnecting) { e.preventDefault(); updateTemporaryLine(isConnecting.tempLineEl, isConnecting.startPos, { x: (pointer.clientX - pan.x) / zoom, y: (pointer.clientY - pan.y) / zoom }); }
        }
        
        function handlePointerUp(e) {
            if (isPanning) { isPanning = false; canvas.style.cursor = 'grab'; }
            if (activeDrag) { saveNodeState(); activeDrag = null; }
            if (isConnecting) {
                isConnecting.tempLineEl.remove();
                let targetEl = e.target;
                if(e.changedTouches) targetEl = document.elementFromPoint(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
                const targetConnector = targetEl?.closest('.node-connector');
                if (targetConnector && targetConnector.dataset.nodeId !== isConnecting.fromNodeId) {
                    createLine({ from: isConnecting.fromNodeId, fromConnector: isConnecting.fromConnector, to: targetConnector.dataset.nodeId, toConnector: targetConnector.dataset.connector });
                }
                isConnecting = null;
            }
        }

        function showContextMenu(x, y) {
            const menu = document.createElement('div'); menu.id = 'context-menu'; menu.classList.add('popover');
            Object.keys(nodeTypes).forEach(type => { const i = document.createElement('div'); i.className = 'context-menu-item'; i.textContent = `Add ${type}`; i.style.borderLeft = `4px solid ${nodeTypes[type].color}`; i.onclick = () => { createNode(type, { x: (x - pan.x) / zoom, y: (y - pan.y) / zoom, title: type }); closeAllPopovers(); }; menu.appendChild(i); });
            menu.style.left = `${x}px`; menu.style.top = `${y}px`; document.body.appendChild(menu);
        }
        
        async function saveNodeState() { if (!currentJobId) return; const nodesToSave = {}; for (const nodeId in nodes) { const { el, ...nodeData } = nodes[nodeId]; nodesToSave[nodeId] = nodeData; } const linesToSave = lines.map(({ el, ...lineData }) => lineData); const newNodeMap = { nodes: nodesToSave, lines: linesToSave }; try { await setDoc(doc(nodeMapsCollection, currentJobId), newNodeMap); } catch (error) { console.error("Error saving node state: ", error); } }
        function loadNodeState(jobId) { world.innerHTML = ''; svgContainer.innerHTML = ''; nodes = {}; lines = []; const map = nodeMaps[jobId]; if (!map) return; if (map.nodes) for (const nodeId in map.nodes) createNode(map.nodes[nodeId].type, map.nodes[nodeId], true); if (map.lines) map.lines.forEach(lineData => createLine(lineData, true)); updateView(); }
        function updateView() { if(!world || !canvas || !svgContainer) return; world.style.transform = `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`; const vbX = -pan.x / zoom, vbY = -pan.y / zoom; const vbW = canvas.clientWidth / zoom, vbH = canvas.clientHeight / zoom; svgContainer.setAttribute('viewBox', `${vbX} ${vbY} ${vbW} ${vbH}`); updateAllLines(); }
        
        function createNode(type, options = {}, isLoading = false) {
            const nodeId = options.id || `node_${Date.now()}`; if (nodes[nodeId]) return;
            const nodeEl = document.createElement('div'); nodeEl.id = nodeId; nodeEl.className = 'node'; nodeEl.style.left = `${options.x || 0}px`; nodeEl.style.top = `${options.y || 0}px`; nodeEl.style.borderTop = `5px solid ${nodeTypes[type]?.color || 'gray'}`;
            nodeEl.innerHTML = `<div class="node-header"><span>${options.title || type}</span><button class="delete-node-btn">&times;</button></div><div class="node-content"><div class="popover-container status-container"></div><div class="popover-container item-assignment-container"><button class="popover-trigger-btn assign-item-btn">Assign Items</button><div class="assigned-items-display"></div></div><div class="comment-box"></div></div><div class="node-connector left" data-connector="left"></div><div class="node-connector right" data-connector="right"></div><div class="node-connector top" data-connector="top"></div><div class="node-connector bottom" data-connector="bottom"></div>`;
            world.appendChild(nodeEl);
            const nodeData = { ...options, id: nodeId, type, el: nodeEl };
            if(!isLoading) { nodeData.status = 'pending'; nodeData.items = []; }
            nodes[nodeId] = nodeData; resizeObserver.observe(nodeEl);
            setupStatusSelector(nodeId, nodeEl.querySelector('.status-container'));
            setupItemAssignment(nodeId, nodeEl.querySelector('.item-assignment-container'));
            setupCommentBox(nodeId, nodeEl.querySelector('.comment-box'));
            const handleDragStart = (e) => { e.preventDefault(); let pointer = e; if (e.touches) pointer = e.touches[0]; activeDrag = { nodeId, el: nodeEl, lastMouse: { x: pointer.clientX, y: pointer.clientY } }; e.stopPropagation(); };
            nodeEl.querySelector('.node-header').addEventListener('mousedown', handleDragStart);
            nodeEl.querySelector('.node-header').addEventListener('touchstart', handleDragStart, {passive: false});
            nodeEl.querySelector('.delete-node-btn').addEventListener('click', e => { deleteNode(nodeId); e.stopPropagation(); });
            const handleConnectStart = (e) => { e.stopPropagation(); if(e.type === 'mousedown' && e.button !== 0) return; const startPos = getConnectorPosition(nodeId, e.currentTarget.dataset.connector); isConnecting = { fromNodeId: nodeId, fromConnector: e.currentTarget.dataset.connector, startPos, tempLineEl: createTemporaryLineElement() }; };
            nodeEl.querySelectorAll('.node-connector').forEach(conn => { conn.dataset.nodeId = nodeId; conn.addEventListener('mousedown', handleConnectStart); conn.addEventListener('touchstart', handleConnectStart, {passive: true}); });
            if (!isLoading) saveNodeState();
        }

        function setupStatusSelector(nodeId, container) {
            const button = document.createElement('button');
            button.className = 'popover-trigger-btn status-btn'; container.appendChild(button);
            const popover = document.createElement('div');
            popover.className = 'popover status-selector-popover'; popover.style.display = 'none';
            Object.entries(statuses).forEach(([key, status]) => {
                const item = document.createElement('div');
                item.className = 'popover-item'; item.textContent = status.text; item.dataset.status = key;
                const setStatus = (e) => { e.stopPropagation(); nodes[nodeId].status = key; updateButton(); saveNodeState(); closeAllPopovers(); };
                item.addEventListener('mousedown', setStatus); item.addEventListener('touchend', setStatus);
                popover.appendChild(item);
            });
            container.appendChild(popover);
            const updateButton = () => {
                const currentStatus = statuses[nodes[nodeId].status] || statuses.pending;
                button.textContent = currentStatus.text; button.style.backgroundColor = currentStatus.bg;
                button.style.color = currentStatus.text === 'Completed' || currentStatus.text === 'Blocked' ? 'white' : (currentStatus.text === 'In Progress' ? 'black' : '#e2e8f0');
            };
            const togglePopover = (e) => { e.stopPropagation(); e.preventDefault(); closeAllPopovers(popover); popover.style.display = popover.style.display === 'block' ? 'none' : 'block'; };
            button.addEventListener('mousedown', togglePopover); button.addEventListener('touchstart', togglePopover);
            updateButton();
        }

        function setupItemAssignment(nodeId, container) {
            const button = container.querySelector('.assign-item-btn'), display = container.querySelector('.assigned-items-display'), job = jobs.find(j => j.id === currentJobId);
            if (!job) return; const popover = document.createElement('div'); popover.className = 'popover item-selector-popover';
            let optionsHTML = '';
            for (let i = 1; i <= job.itemCount; i++) { optionsHTML += `<label><input type="checkbox" value="${i}" ${nodes[nodeId].items?.includes(String(i)) ? 'checked' : ''}> Item ${i}</label>`; }
            popover.innerHTML = optionsHTML; container.appendChild(popover);
            const updateDisplay = () => { display.innerHTML = nodes[nodeId].items?.sort((a,b)=>a-b).map(item => `<span class="item-badge">Item ${item}</span>`).join('') || ''; };
            popover.addEventListener('change', () => { nodes[nodeId].items = Array.from(popover.querySelectorAll('input:checked')).map(input => input.value); updateDisplay(); saveNodeState(); });
            const togglePopover = (e) => { e.stopPropagation(); e.preventDefault(); closeAllPopovers(popover); popover.style.display = popover.style.display === 'block' ? 'none' : 'block'; };
            button.addEventListener('mousedown', togglePopover); button.addEventListener('touchstart', togglePopover);
            updateDisplay();
        }
        
        function setupCommentBox(nodeId, container) {
            const textarea = document.createElement('textarea');
            textarea.className = 'comment-textarea';
            textarea.placeholder = 'Add a comment...';
            container.appendChild(textarea);

            const button = document.createElement('button');
            button.textContent = 'Add Comment';
            button.className = 'btn btn-secondary btn-sm';
            button.style.padding = '4px 8px'; button.style.fontSize = '0.8rem';
            
            button.addEventListener('click', () => {
                const message = textarea.value;
                if (message && message.trim() !== "") {
                    const job = jobs.find(j => j.id === currentJobId);
                    const node = nodes[nodeId];
                    if(job && node) {
                        const commentData = {
                            jobId: currentJobId,
                            jobPrefix: job.prefix,
                            jobNumber: job.number,
                            nodeType: node.type,
                            message: message.trim(),
                            timestamp: serverTimestamp()
                        };
                        addDoc(feedCollection, commentData);
                        // textarea.value = ''; // Line removed as per user request
                    }
                }
            });
            container.appendChild(button);
        }

        function deleteNode(nodeId) { if (!nodes[nodeId]) return; resizeObserver.unobserve(nodes[nodeId].el); lines = lines.filter(line => { if (line.from === nodeId || line.to === nodeId) { line.el?.remove(); return false; } return true; }); nodes[nodeId].el.remove(); delete nodes[nodeId]; saveNodeState(); updateView(); }
        function createLine(lineData, isLoading = false) { const alreadyExists = lines.some(l => (l.from === lineData.from && l.to === lineData.to) || (l.from === lineData.to && l.to === lineData.from)); if (alreadyExists) return; if (!lineData.id) lineData.id = `line_${Date.now()}`; const lineEl = document.createElementNS('http://www.w3.org/2000/svg', 'path'); lineEl.id = lineData.id; lineEl.setAttribute('stroke', '#6b7280'); lineEl.setAttribute('stroke-width', '3'); lineEl.setAttribute('fill', 'none'); lineEl.setAttribute('vector-effect', 'non-scaling-stroke'); lineEl.style.pointerEvents = 'stroke'; lineEl.style.cursor = 'pointer'; lineEl.classList.add('line-path'); lineEl.addEventListener('click', e => { e.stopPropagation(); selectLine(lineData.id); }); svgContainer.appendChild(lineEl); lineData.el = lineEl; lines.push(lineData); updateLine(lineData); if (!isLoading) saveNodeState(); }
        function selectLine(lineId) { deselectLine(); const line = lines.find(l => l.id === lineId); if (line && line.el) { line.el.classList.add('selected'); selectedLineId = lineId; } }
        function deselectLine() { if (selectedLineId) { const line = lines.find(l => l.id === selectedLineId); if (line && line.el) line.el.classList.remove('selected'); selectedLineId = null; } }
        function deleteSelectedLine() { if (!selectedLineId) return; const lineIndex = lines.findIndex(l => l.id === selectedLineId); if (lineIndex > -1) { lines[lineIndex].el.remove(); lines.splice(lineIndex, 1); selectedLineId = null; saveNodeState(); } }
        function updateLine(line) { if (!line.to || !nodes[line.from] || !nodes[line.to]) { if (line.el) line.el.setAttribute('d', ''); return; } const startPos = getConnectorPosition(line.from, line.fromConnector); const endPos = getConnectorPosition(line.to, line.toConnector); const pathData = buildPath(startPos, endPos, line.fromConnector, line.toConnector); if (line.el) line.el.setAttribute('d', pathData); }
        function getConnectorPosition(nodeId, connectorType) { const node = nodes[nodeId]; if (!node || !node.el) return { x: 0, y: 0 }; const nodeEl = node.el; const w = nodeEl.offsetWidth, h = nodeEl.offsetHeight; switch (connectorType) { case 'top': return { x: node.x + w / 2, y: node.y }; case 'bottom': return { x: node.x + w / 2, y: node.y + h }; case 'left': return { x: node.x, y: node.y + h / 2 }; case 'right': return { x: node.x + w, y: node.y + h / 2 }; default: return { x: node.x + w / 2, y: node.y + h / 2 }; } }
        function buildPath(start, end, from, to) { let c1x = start.x, c1y = start.y, c2x = end.x, c2y = end.y; const offset = Math.max(50, Math.abs(start.x - end.x) * 0.3); switch (from) { case 'left': c1x -= offset; break; case 'right': c1x += offset; break; case 'top': c1y -= offset; break; case 'bottom': c1y += offset; break; } switch (to) { case 'left': c2x -= offset; break; case 'right': c2x += offset; break; case 'top': c2y -= offset; break; case 'bottom': c2y += offset; break; } return `M ${start.x} ${start.y} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${end.x} ${end.y}`; }
        function createTemporaryLineElement() { const lineEl = document.createElementNS('http://www.w3.org/2000/svg', 'path'); lineEl.setAttribute('stroke', 'var(--accent-green)'); lineEl.setAttribute('stroke-width', '2'); lineEl.setAttribute('fill', 'none'); lineEl.setAttribute('vector-effect', 'non-scaling-stroke'); svgContainer.appendChild(lineEl); return lineEl; }
        function updateTemporaryLine(lineEl, start, end) { if (lineEl) lineEl.setAttribute('d', buildPath(start, end, 'right', 'left')); }
        function updateAllLines() { if(lines) lines.forEach(updateLine); }
        function updateLinesForNode(nodeId) { if(lines) lines.forEach(l => { if (l.from === nodeId || l.to === nodeId) updateLine(l); }); }
        function closeAllPopovers(exceptThisOne) { document.querySelectorAll('.popover').forEach(p => { if(p !== exceptThisOne) p.style.display = 'none'; }); }

        addJobBtn.addEventListener('click', openAddJobModal);
        backToJobsBtn.addEventListener('click', showJobsList);
        document.getElementById('production-feed-header').addEventListener('click', () => {
            const content = document.getElementById('production-feed-content');
            const arrow = document.getElementById('feed-arrow');
            const isVisible = content.style.display === 'block';
            content.style.display = isVisible ? 'none' : 'block';
            arrow.style.transform = isVisible ? 'rotate(0deg)' : 'rotate(180deg)';
        });
        document.getElementById('modal-cancel-1').addEventListener('click', closeAddJobModal);
        document.getElementById('modal-next-1').addEventListener('click', () => { modalStep1.style.display = 'none'; modalStep2.style.display = 'block'; });
        document.getElementById('modal-back-2').addEventListener('click', () => { modalStep2.style.display = 'none'; modalStep1.style.display = 'block'; });
        document.getElementById('modal-create-job').addEventListener('click', handleCreateJob);
        document.getElementById('item-count-slider').addEventListener('input', e => { document.getElementById('item-count-value').textContent = e.target.value; });
        
        // Start Tone.js on any user interaction
        document.body.addEventListener('click', async () => {
            if (typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
                await Tone.start();
                console.log('Audio context started');
            }
        }, { once: true });


        listenForData();
        showJobsList();
    </script>
</body>
</html>